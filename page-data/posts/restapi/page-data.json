{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/restapi","webpackCompilationHash":"ae3c06da43a38d3aef37","result":{"data":{"markdownRemark":{"id":"3edac84a-bda2-57b4-a52b-6c2a18f5f0a4","html":"<hr>\n<p>본 내용은 위 유투브를 바탕으로 정리한 내용이며, 영상을 보는 겻을 추천한다.</p>\n<hr>\n<p>프로그램 개발을 공부하면서 REST API라는 단어는 자주 들었는데, API라는건 알겠는데 REST는 정확히 어떤것을 뜻하는지 잘 몰랐기에 위 유투브 영상과 다른 사이트들을 참고하여 블로깅을 하려 한다.</p>\n<h3 id=\"rest란\"><a href=\"#rest%EB%9E%80\" aria-label=\"rest란 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>REST란?</h3>\n<p>컴퓨터 시스템간의 상호운영성을 제공하는 것 중에 하나</p>\n<h3 id=\"rest의-역사유래\"><a href=\"#rest%EC%9D%98-%EC%97%AD%EC%82%AC%EC%9C%A0%EB%9E%98\" aria-label=\"rest의 역사유래 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>REST의 역사(유래)</h3>\n<p>1991년 월드 와이드 웹이 나왔을 때 정보공유를 해야 하는데, 어떻게 하면 잘 할수 있을까 라는 고민을 시작으로\n모든 정보들을 하이퍼텍스트로 연결하기로 하여 아래와 같은 것을\n표현 형식: HTML(Hyper Text Markup Language) - TCP/IP기반\n식별자: URI(Uniform Resource Identifier) - 인터넷에 있는 자원 나타내는 유일한 주소(고유한 주소)</p>\n<ul>\n<li>URL과의 차이점: URL은 자원(파일)의 위치(구체적인 주소)를 알려주기 위한 규약이다. 흔히 웹사이트 주소로 알고 있지만, 주소뿐만 아니라 컴퓨터 네트워크상의 자원을 모두 나타낼 수 있다.\n전송방법: HTTP(프로토콜)</li>\n<li>\n<p>하이퍼텍스트 문서를 교환하기 위해 만들어진 통신규약</p>\n<ul>\n<li>request/response 구조로 되어 있고, stateless형태(여러 요청과 응답에 대해 연결되어 있지 않다.)</li>\n<li>Method(GET,POST 등)</li>\n<li>Request target(ex: /login)</li>\n<li>HTTP Version</li>\n</ul>\n</li>\n</ul>\n<p>로이필딩이 HTTP 1.0 작업에 참여 : 기존의 호환성의 문제를 부딪혔는데 어떻게 하면 웹을 망가트리지 않고, HTTP를 증폭시킬 수 있을까</p>\n<p>HTTP Objects model을 만듬 > 4년 후 Rest가 됨 > 2000년도에 나옴</p>\n<p>API\n마이크로 소프트가 XML-RPC 원격으로 다른 시스템의 메소드를 호출할 수 있는 프로토콜을 만듬  > SOAP\nsalesforce에서 2000년 2월에 최초로 API를 SOAP을 사용해서 공개함 > 복잡해서 인기가 없었음\nflickr API SOAP과 REST로 두개의 형식으로 만듬</p>\n<p>SOAP      | REST\n복잡하다    | 단순하다.\n규칙이 많다 |  규칙적음\n어렵다     |  쉽다(초기엔 쉬운줄 알았다.)</p>\n<p>결국 SOAP은 하락하고, REST가 급상승하게 됨 REST의 승리</p>\n<p>REST API는 버저닝을 하지 않는게 최고의 버저닝임</p>\n<p>REST API > REST 아키텍처 스타일을 따르는 API\nREST > 분산 하이퍼 미디어 시스템을 위한 아키텍쳐 스타일\n아키텍쳐 스타일 > 제약조건의 집함(모든 제약조건을 지켜야 REST를 따른다고 함)\nREST를 구성하는 스타일\nclient-server<br>\nstateless<br>\ncache<br>\nuniform interface  </p>\n<ul>\n<li>identification of resources</li>\n<li>manipulation of resources through representations</li>\n<li><strong>self-descriptive messages</strong></li>\n<li><strong>hypermedia as the engine of application state (HATEOAS)</strong></li>\n</ul>\n<h3 id=\"uniform-interface\"><a href=\"#uniform-interface\" aria-label=\"uniform interface permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>uniform interface</h3>\n<p>uniform interface가 필요한 이유\n<strong>독립적 진화를 하기 위해서 필요함</strong>\n서버와 클라이언트가 독립적이어야 함\n서버의 기능이 바뀌어도(API변경(추가, 수정 삭제), URI변경 등 ) 클라이언트의 업데이트가 없어야 함</p>\n<ul>\n<li>identification of resources: 리소스가 URI로 식별되면 된다.</li>\n<li>manipulation of resources through representations : 리소스를 만들거나 업데이트 하거나 삭제할 때 HTTP 메세지에 표현을 담아서 전송을 통해서 달성하면(조작하면) 된다.</li>\n<li>\n<p><strong>self-descriptive messages</strong> : 메세지는 스스로를 설명해야 한다. >\n예를 들어 <code class=\"language-text\">GET / HTTP/1.1</code>이라는 요청메세지가 있다면,</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">GET / HTTP/1.1\nHost: www.example.org</code></pre></div>\n<p>목적지를 추가해야 self-descriptive를 지킨다고 할 수 있다.\n또한,</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">HTTP/1.1 200 OK\n[ { &quot;op&quot;: &quot;remove&quot;, &quot;path&quot;: &quot;a/b/c&quot;} ]</code></pre></div>\n<p>일 때, 어떤 문법으로 작성되어 있는 건지 모르기 때문에 REST API라 부를 수 없으며, 아래와 같이 출력되어야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">HTTP/1.1 200 OK\nContent-Type: application/json/json-patch+json # 미디어 타입의 json\n[ { &quot;op&quot;: &quot;remove&quot;, &quot;path&quot;: &quot;a/b/c&quot;} ]</code></pre></div>\n<p>어떤 타입인지 명시를 해줘야 한다.</p>\n<p><strong>메세지를 봤을 때 메세지의 내용으로 온전히 해석이 가능해야 한다. 하지만 오늘날에는 잘 못지켜지고 있음</strong></p>\n</li>\n<li><strong>hypermedia as the engine of application state (HATEOAS)</strong>\n현재의 URI에서 다음 URI를 명세했는지?(표현된 링크를 통해 다음 상태로 전이될 수 있는지를 보고 만족유무를 판단)</li>\n</ul>\n<p>layered system<br>\ncode-on-demand(optional) 서버에서 코드를 클라이언트에게 보내서 실행할 수 있어야 함 (JAVASCRIPT)</p>\n<p>웹 애플리케이션에서는 REST API라고 부를 수 있을 만큼 잘 지켜지고 있지만, 모바일 앱 애플리케이션은 잘 안지켜지고 있다고 한다.   </p>\n<p>웹은,</p>\n<ul>\n<li>웹 페이지를 변경했다고 웹 브라우저를 업데이트할 필요는 없다.  </li>\n<li>웹 브라우저를 업데이트했다고 웹 페이지를 변경할 필요도 없다.  </li>\n<li>HTTP 명세가 변경되어도 웹은 잘 작동한다.  </li>\n<li>HTML 명세가 변경되어도 웹은 잘 작동한다.  </li>\n</ul>\n<p>모바일 웹은 문제를 업데이트를 하면 문제가 되고 있음\n서버가 기능을 변경했는데, 클라이언트가 호환성을 지원해주는게 한계가 있고, 잦을 때도 있다.<br>\n<strong>REST API</strong> 를 따르고 있지 않다고 보면 됨</p>\n<p>결론: 웹은 이런 일이 거의 없지만 모바일 웹에서는 잦은 일이다.</p>\n<p>웹이 잘 작동하는 이유<br>\n상호운용성(interoperability)에 대한 직착 때문임<br>\n버전업이 아닌 문서를 수정하고 보완하는데도 많은 시간을 소비(10년 정도)하고, 하위 호환을 하기 위해 수많은 개발자 들이 머리를 싸매고 꾸준한 노력을 하기 때문임<br>\n하위호환: 예를 들어 현재 Rederer, charset 등 오타가 났고, 잘못 지은 이름이지만 수정하게 되면 상호운영성이 깨져기 때문임  </p>\n<h3 id=\"rest가-웹의-독립적-진화에-도음을-주었는가\"><a href=\"#rest%EA%B0%80-%EC%9B%B9%EC%9D%98-%EB%8F%85%EB%A6%BD%EC%A0%81-%EC%A7%84%ED%99%94%EC%97%90-%EB%8F%84%EC%9D%8C%EC%9D%84-%EC%A3%BC%EC%97%88%EB%8A%94%EA%B0%80\" aria-label=\"rest가 웹의 독립적 진화에 도음을 주었는가 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>REST가 웹의 독립적 진화에 도음을 주었는가??</h3>\n<ul>\n<li>\n<p>HTTP에 지속적으로 영향을 줌</p>\n<ul>\n<li>Host 헤더 추가</li>\n<li>길이 제한을 다루는 방법이 명시</li>\n<li>URI에서 리소스의 정의가 추상적으로 변경됨: “식별하고자 하는 무언가” > 예전에는 문서의 위치가 정의되었었음</li>\n<li>기타 HTTP와 URI에 많은 영향을 줌</li>\n<li>HTTP/1.1 명세 최신판에서 REST에 대한 언급이 들어감</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"rest가-성공했는가\"><a href=\"#rest%EA%B0%80-%EC%84%B1%EA%B3%B5%ED%96%88%EB%8A%94%EA%B0%80\" aria-label=\"rest가 성공했는가 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>REST가 성공했는가?</h3>\n<ul>\n<li>REST는 웹의 독립적 진화를 위해 만들어졌다.</li>\n<li>\n<p>웹은 독립적으로 진화하고 있다.</p>\n<blockquote>\n<blockquote>\n<p>성공!!</p>\n</blockquote>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"rest-api는\"><a href=\"#rest-api%EB%8A%94\" aria-label=\"rest api는 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>REST API는?</h3>\n<ul>\n<li>REST API는 REST 아키텍쳐 스타일을 따라야 한다.</li>\n<li>오늘날 스스로 REST API라고 하는 API들의 대부분이 REST 아키텍쳐 스타일을 따르지 않는다.</li>\n</ul>\n<h4 id=\"제약-조건을-모두-지켜야-하는가\"><a href=\"#%EC%A0%9C%EC%95%BD-%EC%A1%B0%EA%B1%B4%EC%9D%84-%EB%AA%A8%EB%91%90-%EC%A7%80%EC%BC%9C%EC%95%BC-%ED%95%98%EB%8A%94%EA%B0%80\" aria-label=\"제약 조건을 모두 지켜야 하는가 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>제약 조건을 모두 지켜야 하는가?</h4>\n<ul>\n<li>로이필드가 제약조건을 모두 지켜야 한다고 명시를 함</li>\n</ul>\n<h4 id=\"꼭-rest-api여야-하는건가\"><a href=\"#%EA%BC%AD-rest-api%EC%97%AC%EC%95%BC-%ED%95%98%EB%8A%94%EA%B1%B4%EA%B0%80\" aria-label=\"꼭 rest api여야 하는건가 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>꼭 REST API여야 하는건가?</h4>\n<ul>\n<li>\n<p>로이필드가 아니여도 상관없다고 한다.</p>\n<blockquote>\n<blockquote>\n<p>시스템 전체를 통제할 수 있다고 생각하거나, 진화에 관심이 없다면, REST에 대해 따지느라 시간을 낭비하지 마라</p>\n</blockquote>\n</blockquote>\n</li>\n</ul>\n<p>시스템 전체를 통제: 서버개발자가 클라이언트를 통제하거나, 혼자 모두 다 만들 수 있을 때\n진화에 관심이 없다는 것: 잦은 업데이트로 문제가 생겼다는 것을 듣고도 상관없다면,,</p>\n<h3 id=\"어떻게-해야-할까\"><a href=\"#%EC%96%B4%EB%96%BB%EA%B2%8C-%ED%95%B4%EC%95%BC-%ED%95%A0%EA%B9%8C\" aria-label=\"어떻게 해야 할까 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>어떻게 해야 할까?</h3>\n<ol>\n<li>REST API를 구현하고 REST API라고 부른다.</li>\n<li>REST API 구현을 포기하고  HTTP API라고 부른다.</li>\n<li><strong>REST API가 아니지만 REST API라고 부른다.(현재)</strong></li>\n</ol>\n<h3 id=\"웹은-잘-되는데-api는-왜-문제가-되는지\"><a href=\"#%EC%9B%B9%EC%9D%80-%EC%9E%98-%EB%90%98%EB%8A%94%EB%8D%B0-api%EB%8A%94-%EC%99%9C-%EB%AC%B8%EC%A0%9C%EA%B0%80-%EB%90%98%EB%8A%94%EC%A7%80\" aria-label=\"웹은 잘 되는데 api는 왜 문제가 되는지 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>웹은 잘 되는데 API는 왜 문제가 되는지??</h3>\n<ul>\n<li>\n<p>HTML과 JSON의 차이에 대해 알아야 한다.</p>\n<ul>\n<li>문법 해석은 가능하지만 의미를 해석하려면 별도로 문서가(API문서 등) 필요하다.</li>\n</ul>\n</li>\n</ul>\n<p>HTML의 경우</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">#예시\nGET / todos HTTP/1.1\nHost: example.org\n\nHTTP/1.1 200 OK\nContent-Type : text/html\n\n&lt;html&gt;\n&lt;body&gt;\n&lt;a href=&quot;https://todos/1&quot;&gt; 회사 가기&lt;/a&gt;\n&lt;a href=&quot;https://todos/2&quot;&gt; 집에 가기&lt;/a&gt;\n&lt;body&gt;\n&lt;html&gt;</code></pre></div>\n<p>Self-descriptive = 모든 태그의 해석방법이 구체적으로 나와 있고, 힌트만을 단서로 온전히 해석할 수 있음 <strong>SUCCESS</strong>\nHATEOAS = a태그를 통해 다음 전이될 페이지를 명시함 <strong>SUCCESS</strong></p>\n<p>JSON의 경우  </p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">GET / todos HTTP/1.1\nHost:L exampele.org\n\nHTTP/1.1 200 OK\nContent-Type: application/json\n[\n  {&quot;id&quot;: 1, &quot;title&quot;: &quot;회사 가기&quot;},\n  {&quot;id&quot;: 2, &quot;title&quot;: &quot;집에 가기&quot;},\n]</code></pre></div>\n<p>Self-descriptive = id가 무엇을 의미하는지, title이 무엇을 의미하는지 알 방법이 없음 <strong>FAIL</strong>\nHATEOAS = 다음으로 전이될 페이지가 명시되어 있지 않다 <strong>FAIL</strong></p>\n<h3 id=\"과연-두가지의-제약조건self-descriptive-hateoas가-독릭적인-진화에-어떻게-도움이-될까\"><a href=\"#%EA%B3%BC%EC%97%B0-%EB%91%90%EA%B0%80%EC%A7%80%EC%9D%98-%EC%A0%9C%EC%95%BD%EC%A1%B0%EA%B1%B4self-descriptive-hateoas%EA%B0%80-%EB%8F%85%EB%A6%AD%EC%A0%81%EC%9D%B8-%EC%A7%84%ED%99%94%EC%97%90-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%8F%84%EC%9B%80%EC%9D%B4-%EB%90%A0%EA%B9%8C\" aria-label=\"과연 두가지의 제약조건self descriptive hateoas가 독릭적인 진화에 어떻게 도움이 될까 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>과연 두가지의 제약조건(self-descriptive, HATEOAS)가 독릭적인 진화에 어떻게 도움이 될까?</h3>\n<p>Self-descriptive: 확장 가능한 커뮤니케이션<br>\n서버나 클라이언트가 변경되더라도 오고가는 메세지는 언제나 해석이 가능하다  </p>\n<p>HATEOAS : 애플리케이션 상태 전이의 late binding\n링크들을 동적(마음대로) 바꿀 수 있고, 서버가 바꿔도 클라이언트의 동작은 전혀 문제가 없다.</p>\n<h3 id=\"json-수정\"><a href=\"#json-%EC%88%98%EC%A0%95\" aria-label=\"json 수정 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JSON 수정</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">GET / todos HTTP/1.1\nHost:L exampele.org\n\nHTTP/1.1 200 OK\nContent-Type: application/json\n[\n  {&quot;id&quot;: 1, &quot;title&quot;: &quot;회사 가기&quot;},\n  {&quot;id&quot;: 2, &quot;title&quot;: &quot;집에 가기&quot;},\n]</code></pre></div>\n<p>Self-descriptive</p>\n<ol>\n<li>\n<p>Content-Type: application/vnd/todos+json으로 수정 후 IANA에 내용 등록</p>\n<blockquote>\n<p>매번 media type을 정의해야 한다.</p>\n</blockquote>\n</li>\n<li>\n<p>headers에 <code class=\"language-text\">Link: &lt;https://example.org/docs/todos&gt;; rel=&quot;profile&quot;</code>을 명시하고, id가 어떤건지 명시하는 문서를 하나 작성한다.</p>\n<blockquote>\n<p>클라이언트가 link헤더와 프로필을 이해해야 한다. Content negotiation을 할 수 없다.</p>\n</blockquote>\n</li>\n</ol>\n<p>HATEOAS</p>\n<p>본문에 링크를 추가해서 보내기 > 링크표현 방법을 직접 정의해야 한다.(링크헤더에서 프로필을 정리, 문서에 정의)\n데이터에 다양한 방법으로 하이퍼링크를 표현 >\nJSON으로 하이퍼링크를 표현하는 방법을 정의한 명세들을 활용 > 기존 API를 많이 고쳐야 함(침투적)</p>\n<blockquote>\n<p>data, headers를 통해 활용해서 표현할 수 있다.</p>\n</blockquote>\n<p>정리\n오늘날 REST API는 사실 REST를 많이 따르지 않는다고 한다.\nREST의 제약조건 중 Self-descriptive와 HATEOAS를 만족하지 못한다.\nREST는 긴 시간에 걸쳐 진화하는 웹 애플리케이션을 위한 것이다.\n따를 것인지 스스로 판단하여 결정해야 한다.</p>\n<ul>\n<li>Self-descriptive와 HATEOAS를 만족시켜야 함<br>\n따르지 않을 경우 어떻게 부를것인지??</li>\n</ul>\n<p>참고\n<a href=\"https://www.youtube.com/watch?v=RP_f5dMoHFc\">그런 REST API로 괜찮은가?</a></p>","fields":{"slug":"/posts/restapi","tagSlugs":["/tag/rest-api/","/tag/wecode/","/tag/api/"]},"frontmatter":{"date":"2019-07-26T012:46:37.121Z","description":"REST API","tags":["REST API","Wecode","API"],"title":"REST API란?"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/posts/restapi"}}}