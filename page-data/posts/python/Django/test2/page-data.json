{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/python/Django/test2","webpackCompilationHash":"b82d9b28d8528598d6d8","result":{"data":{"markdownRemark":{"id":"b4049848-3568-5d01-8337-0fafb471d47b","html":"<hr>\n<p>일전에 블로깅 했던 <a href=\"https://koreanblacklee.github.io/posts/python/test\">System Test</a>에서 얘기한 Mock 테스트에 대해 더 알아보고자 한다.</p>\n<h3 id=\"why-unit-testing-is-important\"><a href=\"#why-unit-testing-is-important\" aria-label=\"why unit testing is important permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Why Unit Testing is Important?</h3>\n<p>모듈이나 애플리케이션 안에 있는 개별적인 코드들의 <strong>가장 작은 단위</strong>에서 코드들이 원하는대로 작동하는지 테스트하는 것을 Unittest라고 하며, 유닛테스트는,  </p>\n<ul>\n<li>각각의 코드들이 어떤 동작을 하는지 생각하는데 도움을 준다.</li>\n<li>버그를 찾고, 버그를 고쳤을 때 문제가 없는지를 확인한다.</li>\n</ul>\n<blockquote>\n<blockquote>\n<p><strong>각각의 코드들이 문제가 없는지, 효율적인지, 버그수정 후 이상없는지 등을 확인하기 위한 테스트</strong></p>\n</blockquote>\n</blockquote>\n<h3 id=\"what-is-mock\"><a href=\"#what-is-mock\" aria-label=\"what is mock permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>What is Mock?</h3>\n<p>실제 객체를 만들기엔 비용이나 시간이 많이 들거나 <strong>의존성이 걸처져 있어</strong> 제대로 구현하기 어려울 경우, 유닛테스트를 하기 위해 response되야 할 <strong>거짓된</strong> 객체를 직접 만들어 테스트를 한다고 생각하면 된다.</p>\n<h3 id=\"when-should-use-mock\"><a href=\"#when-should-use-mock\" aria-label=\"when should use mock permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>When should use Mock?</h3>\n<p>유닛테스트를 하다 보면 테스트를 하기 위해 실제로 실행할 수 없는 코드들이 있다.<br>\n예를 들어, SMS 문자, 결제 API, 플랫폼 소셜 로그인 등이 있을 수 있다.\n즉, 외부 API를 실제로 호출하게 되면 결제가 되고, 문자가 보내지는 등 테스트를 위한 추가적인 시간과 비용이 발생할 수 있는 코드들을 테스트 하기 위해서 <code class=\"language-text\">Mock</code>(거짓된 값)을 이용한 테스트를 시행한다.<br>\nStackoverflow나 구글링을 해보면 많은 설명과 사례들이 있으니 시간내서 보는 것도 좋을 듯 하다.</p>\n<p><a href=\"https://stackoverflow.com/questions/3622455/what-is-the-purpose-of-mock-objects\">stackoverflow: What is the purpose of mock objects?</a><br>\n(좀 오래된 듯 하지만 답변에 mock테스트 관련해서 기본적인 개념이 잘 설명되 있는 듯 해서 퍼왔다.(물론 크롬번역을 통해서 봤지만,,,))</p>\n<blockquote>\n<blockquote>\n<p><strong>테스트 환경을 구축하기 어려운 경우, 특정경우나 의존적인 경우, 테스트 시간이 오래 걸리는 경우 등의 이유로 사용된다.</strong></p>\n</blockquote>\n</blockquote>\n<hr>\n<p>Mock을 사용하기 위해 <code class=\"language-text\">Patch</code>라는 것을 사용해야 되며(물론 안쓸 때도 있긴 하겠지만 난 썻다.) Patch가 어떤건지 알아보자.  </p>\n<h3 id=\"what-is-patch\"><a href=\"#what-is-patch\" aria-label=\"what is patch permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>What is Patch?</h3>\n<p>쉽게 말해 영어로 “땜빵”이라는 뜻이다. 원래는 옷에 뚫린 구멍을 기우는데 쓰는 천 쪼가리를 패치라고 부르며, 여기에선 런타임 시 속성을 동적으로 대체하는 것을 말한다.<br>\n예를 들어, 이번에 포스팅 예제로 쓰일 카카오톡 소셜로그인의 로직을 정리하면,<br>\n제작 중인 웹사이트에서 카카오톡 소셜로그인을 이용하기 위해선,(백엔드 기준) </p>\n<ol>\n<li>프론트엔드에서 받은 access_token을 카카오톡 API로 보내고 </li>\n<li>requests모듈을 통해 받은 사용자의 정보를 확인하고,  </li>\n<li>데이터에 <code class=\"language-text\">True</code>이거나 <code class=\"language-text\">False</code>일 때 코딩한대로(원하는대로) 흘러가는지 테스트를 하기 위해선 아래와 같은 patch를 사용하면 된다.</li>\n</ol>\n<p><code class=\"language-text\">@patch(&quot;account.views.requests&quot;)</code>(account앱에서 views.py에 있는 requests모듈을 패치할 것이라는 뜻)</p>\n<h3 id=\"how-to-mocking-test\"><a href=\"#how-to-mocking-test\" aria-label=\"how to mocking test permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>How to Mocking Test?</h3>\n<p>그럼 어떻게 테스트를 해야 하는지 아래 코드를 통해 확인해보자</p>\n<ol>\n<li>구축환경: 장고 2.2, python 3.7 </li>\n<li>홈페이지 관리자의 카카오톡 소셜로그인을 하는 코드를 테스트하기 위해 작성</li>\n</ol>\n<h4 id=\"로직-순서\"><a href=\"#%EB%A1%9C%EC%A7%81-%EC%88%9C%EC%84%9C\" aria-label=\"로직 순서 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>로직 순서</h4>\n<ol>\n<li>\n<p>views.py</p>\n<ul>\n<li>소셜로그인 코드 작성(최초 request는 프론트엔드에서 카카오톡 <code class=\"language-text\">access token</code>을 전달 받음)</li>\n<li>카카오톡 토큰을 카카오톡 API로 보내 사용자의정보를 <code class=\"language-text\">requests</code> 요청 (추후 이 부분을 mocking할 것임)</li>\n<li>카카오톡에서 받은 정보 중 <code class=\"language-text\">nickname</code>이 DB에 동일한 관리자가 있는지 확인(특수한 경우로 보통 카카오 ID을 기준으로 함)<a href=\"https://koreanblacklee.github.io/posts/djangsociallogin/\">구글,카카오 소셜로그인</a> 페이지 확인</li>\n<li><code class=\"language-text\">nickname</code>이 같은 관리자가 존재하고, 해당 관리자가 카카오톡으로 회원가입 했는지 확인(카카오톡 에서 받은 정보 중 <code class=\"language-text\">id</code>가 고유값이기 떄문에 해당 값을 이용해서 파악)</li>\n<li>기존에 가입했다면 바로 로그인, 가입하지 않았다면 Employee Table에 저장(<strong>본래 관리자 중에 동일한 이름이 없을 경우 예외처리를 해주어야 하지만, 해당 부분은 제외했습니다.</strong>)</li>\n</ul>\n</li>\n<li>\n<p>tests.py</p>\n<ul>\n<li>테스트를 위해 <code class=\"language-text\">EmployeeTest</code>클래스를 만들고 <code class=\"language-text\">setUp</code>(EB에 가짜 사용자를 create함), <code class=\"language-text\">tearDown</code>(하나의 테스트함수가 실행된 후 해당 테스트의 데이터 삭제하는 함수로 setUp함수와 함께 사용된다고 알면 된다.)를 만든다.</li>\n<li>테스트 class안에 <code class=\"language-text\">test_employee_kakao_account</code>작성 및 <code class=\"language-text\">@patch(&quot;account.views.requests&quot;)</code> 데코레이터 작성</li>\n<li><code class=\"language-text\">MockedResponse</code>mock test에 사용할 class 작성(카카오톡에서 얻을 정보 중 활용할 정보들을 작성)</li>\n<li><code class=\"language-text\">MagicMock(return_value = MockedResponse)</code>을 requests.post 함수에 저장</li>\n<li>나머지는 기존 테스트 코드와 동일한 코드이기 때문에별도의 설명 생략함.</li>\n</ul>\n</li>\n</ol>\n<p><strong>필수사항</strong>  </p>\n<ul>\n<li>각 클래스와 함수별로 기능을 작성해두었고, 나머지는 코드를 보고 이해하면서 공부를 해보길 바란다.  </li>\n<li>코드가 길어서 눈에 안들어올 수 있고, 어떤 뜻인지 모를 수 있지만 차근차근 보다보면 이해되니 끈기를 갖고 봐보자.</li>\n</ul>\n<p><strong>주의사항</strong><br>\npatch가 어디서 어떻게 작동될지 모르기 때문에(?)생각한대로 나오는지 계속 print를 찍어보면서 확인해야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">#views.py\nimport json\nimport bcrypt\nimport jwt\nimport requests\n\nfrom settings       import SECRET_KEY, EXP_TIME\nfrom account.models import Employee\nfeom django.views   import View\nfrom django.http    import JsonResponse\n\n\nclass EmployeeSocialLoginView(View): #카카오톡 소셜로그인을 위한 클래스\n\n    @employee_login_required # employee가 로그인 상태인지 확인하기 위한 데코레이터\n    def post(self, request): # frontend에 post로 카카오톡 소셜로그인 토큰을 request 받음\n\n        #토큰을 이용해서 카카오톡에 사용자 정보 확인 요청(requests가 핵심)\n        access_token = request.headers[&quot;Authorization&quot;]\n        headers      = ({&#39;Authorization&#39; : f&quot;Bearer {access_token}&quot;})\n        url          = &quot;https://kapi.kakao.com/v1/user/me&quot;\n        response     = requests.post(url, headers=headers, timeout=3)\n        employee     = response.json()\n        exp_time = EXP_TIME\n\n        # 관리자가(employee) 기존에 카카오톡 계정이 DB에 저장되어 있는지 확인\n        if Employee.objects.filter(kakao_id = employee[&quot;id&quot;]).exists():\n            exp_time = EXP_TIME\n            siren_secret = SECRET_KEY\n\n            employee_data = Employee.objects.get(kakao_id = employee[&quot;id&quot;])\n            encoded_jwt = jwt.encode({&quot;employee_id&quot;:employee_data.id, &#39;exp&#39;:exp_time}, siren_secret, algorithm=&quot;HS256&quot;)\n\n            login_check = Login(\n                employee = Employee.objects.get(employee_code=employee_data.employee_code)\n            )\n            login_check.save()\n\n            return JsonResponse(\n                {\n                    &#39;access_token&#39; : encoded_jwt.decode(&#39;UTF-8&#39;),\n                    &#39;name&#39;         : employee_data.name,\n                    &#39;message&#39;      : &#39;SUCCESS&#39;\n                }, status = 200\n            )\n\n        #저장되어 있지 않다면 DB에 저장\n        else:\n            employee_info = Employee.objects.get(name=employee[&#39;properties&#39;][&#39;nickname&#39;])\n            employee_info.kakao_id = employee[&quot;id&quot;]\n            employee_info.save()\n\n            return JsonResponse(\n                {\n                    &quot;message&quot;: &quot;SUCCESS&quot;\n                }, status = 200\n            )</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">#tests.py\nimport json\nfrom account.models import Employee\nfrom django.test    import TestCase, Client\nfrom unittest.mock  import patch, MagicMock\n\n#setUp, tearDown을 통한 사전설정 \nclass EmployeeTest(TestCase):\n    def setUp(self):\n        bytes_pw = bytes(&#39;1234&#39;, &#39;utf-8&#39;)\n        hashed_pw = bcrypt.hashpw(bytes_pw, bcrypt.gensalt())\n        Employee.objects.create(\n            name          = &#39;아이유&#39;,\n            user_id       = &#39;100011&#39;,\n            password      = hashed_pw.decode(&#39;UTF-8&#39;),\n            phone_number  = &#39;010-1234-1111&#39;,\n           )\n\n    def tearDown(self):\n        Employee.objects.filter(name=&#39;아이유&#39;).delete()\n\n\n    #patch, MagicMock을 이용한 테스트\n    @patch(&quot;account.views.requests&quot;)\n    def test_employee_kakao_account(self, mocked_requests):\n        c = Client()\n\n        class MockedResponse:\n            def json(self):\n                return {\n                    &quot;id&quot; : &quot;12345&quot;,\n                    &quot;properties&quot; : {\n                        &quot;nickname&quot; : &quot;아이유&quot;\n                    }\n                }\n\n        mocked_requests.post = MagicMock(return_value = MockedResponse())\n\n        test = {\n            &#39;employee_code&#39;:&#39;1000111&#39;,\n            &#39;password&#39;:&#39;1234&#39;,\n            &#39;nickname&#39; : &#39;아이유&#39;\n        }\n\n        response = c.post(&quot;/account/employee/kakao&quot;, json.dumps(test), **{&quot;HTTP_AUTHORIZATION&quot;:&quot;1234&quot;,&quot;content_type&quot; : &quot;application/json&quot;})\n\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(\n            response.json(),\n                {\n                    &#39;message&#39; : &#39;SUCCESS&#39;\n                }\n        )</code></pre></div>\n<ul>\n<li>참고<br>\n<a href=\"https://blog.leop0ld.org/posts/about-mocking/\">Mock</a> : 오브젝트들을 동적으로 대체하고 사용결과를 확인하기 위한 다양한 기능들을 제공, 의존성이 잇는 것들을 실제로 실행시키지 않고 호출여부, 인터페이스를 확인할 수 있다.<br>\n<a href=\"https://gist.github.com/evansde77/45467f5a7af84d2a2d34f3fcb357449c\">mock_requests</a> 원본</li>\n</ul>","fields":{"slug":"/posts/python/Django/test2","tagSlugs":["/tag/python-3/","/tag/wecode/","/tag/mocking-test/"]},"frontmatter":{"date":"2019-07-26T012:46:37.121Z","description":"Python Mocking Test","tags":["Python3","Wecode","mocking test"],"title":"Python Mocking Test(mock, patch)"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/posts/python/Django/test2"}}}